#pragma warning disable S3218 // Inner class members should not shadow outer class "static" or type members
// leads to easier to read code in this case.

using System.Runtime.CompilerServices;

namespace Qowaiv.Text;

internal static class ASCII
{
    [Pure]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsAscii(char c) => c < 127;

    [Pure]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsDigit(char c) => c >= '0' && c <= '9';

    /// <summary>Returns the digit value of the char.</summary>
    /// <remarks>
    /// Assumes that the char represents a digit.
    /// </remarks>
    [Pure]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int Number(char c) => c - '0';

    [Pure]
    public static bool IsLetter(char c) => (Category[c] & Is.Letter) != 0;

    [Pure]
    public static bool IsLetterOrDigit(char c) => (Category[c] & Is.LetterOrDigit) != 0;

    [Pure]
    public static bool IsMarkup(char c) => (Category[c] & (Is.Markup | Is.Whitespace)) != 0;

    [Pure]
    public static char Upper(char c) => (Category[c] & Is.LowerCase) == 0 ? c : (char)(c & 0x5F);

    private static readonly byte[] Category =
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00,
        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x10,
        0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
        0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    public static class EmailAddress
    {
        /// <summary>Returns true for chars that could be part of the local part.</summary>
        /// <remarks>The . is not included for practial reasons.</remarks>
        [Pure]
        public static bool IsLocal(char c) => (Category[c] & Is.Local) != 0;

        [Pure]
        public static bool IsDomain(char c) => (Category[c] & Is.Domain) != 0;

        [Pure]
        public static bool IsTopDomain(char c) => (Category[c] & Is.TopDomain) != 0;

        [Pure]
        public static bool IsPunycode(char c) => (Category[c] & Is.Punycode) != 0;

        private static readonly byte[] Category =
        [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x09, 0x00, 0x01,
            0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01,
            0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
            0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x01, 0x03,
            0x01, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
            0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x01, 0x01, 0x01, 0x01, 0x00,
        ];

        private static class Is
        {
            public const byte Local = /*.....*/ 0b00001;
            public const byte Domain = /*....*/ 0b00010;
            public const byte TopDomain = /*.*/ 0b00100;
            public const byte Punycode = /*..*/ 0b01000;
        }
    }

    private static class Is
    {
        public const byte Whitespace = /*.*/ 0b00001;
        public const byte Digit = /*......*/ 0b00010;
        public const byte UperCase = /*...*/ 0b00100;
        public const byte LowerCase = /*..*/ 0b01000;
        public const byte Markup = /*.....*/ 0b10000;
        public const byte Letter = UperCase | LowerCase;
        public const byte LetterOrDigit = Letter | Digit;
    }
}
